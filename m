Return-Path: <linux-iio-owner@vger.kernel.org>
X-Original-To: lists+linux-iio@lfdr.de
Delivered-To: lists+linux-iio@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.lfdr.de (Postfix) with ESMTP id C83DBF6911
	for <lists+linux-iio@lfdr.de>; Sun, 10 Nov 2019 14:17:23 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726436AbfKJNRX (ORCPT <rfc822;lists+linux-iio@lfdr.de>);
        Sun, 10 Nov 2019 08:17:23 -0500
Received: from mail.kernel.org ([198.145.29.99]:34412 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726301AbfKJNRX (ORCPT <rfc822;linux-iio@vger.kernel.org>);
        Sun, 10 Nov 2019 08:17:23 -0500
Received: from archlinux (cpc149474-cmbg20-2-0-cust94.5-4.cable.virginm.net [82.4.196.95])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id ABB1D20842;
        Sun, 10 Nov 2019 13:17:18 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1573391841;
        bh=n6eieICV9fpsmR8YyS99qjKMVAWkKkZiWmeks0PtMTU=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=Mmyl38pR2EBVHSCGaLHGqj6zFVUoFz758/hun0rD4BxOEjXi+fKD9y+AE9Uys6hqK
         S7HfVV9qfFcGGKyHYIvrUAWUe67RhfOE7V45LD298KQnSyamV59xpb+DM37SAx+W9v
         j/40z6/w8E9gTzUGre0yIWf9xHknZMHvNc5Pjqhk=
Date:   Sun, 10 Nov 2019 13:17:14 +0000
From:   Jonathan Cameron <jic23@kernel.org>
To:     Gwendal Grignou <gwendal@chromium.org>
Cc:     briannorris@chromium.org, knaack.h@gmx.de, lars@metafoo.de,
        pmeerw@pmeerw.net, lee.jones@linaro.org, bleung@chromium.org,
        enric.balletbo@collabora.com, dianders@chromium.org,
        groeck@chromium.org, fabien.lahoudere@collabora.com,
        linux-kernel@vger.kernel.org, linux-iio@vger.kernel.org
Subject: Re: [PATCH v4 13/17] iio: cros_ec: Register to cros_ec_sensorhub
 when EC supports FIFO
Message-ID: <20191110131714.098ee2ea@archlinux>
In-Reply-To: <20191105222652.70226-14-gwendal@chromium.org>
References: <20191105222652.70226-1-gwendal@chromium.org>
        <20191105222652.70226-14-gwendal@chromium.org>
X-Mailer: Claws Mail 3.17.4 (GTK+ 2.24.32; x86_64-pc-linux-gnu)
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: quoted-printable
Sender: linux-iio-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-iio.vger.kernel.org>
X-Mailing-List: linux-iio@vger.kernel.org

On Tue,  5 Nov 2019 14:26:48 -0800
Gwendal Grignou <gwendal@chromium.org> wrote:

> When EC supports FIFO, each IIO device registers a callback, to put
> samples in the buffer when they arrives from the FIFO.
> We can still use a trigger to collect samples, but there may be some
> duplications in the buffer: EC has a single FIFO, so once one sensor is
> using it, all sensors event will be in the FIFO.
> To be sure events generated by cros_ec_sensorhub or the trigger uses the
> same time domain, current_timestamp_clock must be set to "boottime".

How is that enforced?  I'd have no problem with core support for IIO
to allow a driver that has requirements like this to override
the normal flexibility.

>=20
> When no FIFO, the user space app needs to call trigger_new, or better
> register a high precision timer.
>=20
> Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
A question + a comment that I'm still not happy with the fact we have
to protect against a race on startup.  However, we can perhaps make that
a problem for another day.

Assuming the question on the mode mask change is resolved.
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

> ---
> Changes in v4:
> - Fix a logic error when the sensor is not "physical", for instance lig
>   angle: core_init() would return !0 even if there was no error.
> - Check patch with --strict option
>     Use sizeof(*obj) instead of sizeof(struct ...obj)
>     Alignement
> Change in v3:
> - Remove double line
> - Fix indentation
> - Add code to support iio clock_id setting. Optimized for
>   CLOCK_BOOTTIME.
> Change in v2 from "Use triggered buffer only when EC does not support
> FIFO":
> - Keep trigger all the time.
> - Add  devm_add_action to cleanup callback registration.
> - EC that "reports" legacy sensors do not have FIFO.
> - Use iiio_is_buffer_enabled instead of checking the scan_mask
>   before sending samples to buffer.
> - Add empty lines for visibility.
>=20
>  drivers/iio/accel/cros_ec_accel_legacy.c      |  8 +-
>  .../cros_ec_sensors/cros_ec_lid_angle.c       |  2 +-
>  .../common/cros_ec_sensors/cros_ec_sensors.c  |  9 +-
>  .../cros_ec_sensors/cros_ec_sensors_core.c    | 85 ++++++++++++++++++-
>  drivers/iio/light/cros_ec_light_prox.c        |  9 +-
>  drivers/iio/pressure/cros_ec_baro.c           |  9 +-
>  .../linux/iio/common/cros_ec_sensors_core.h   | 10 ++-
>  7 files changed, 103 insertions(+), 29 deletions(-)
>=20
> diff --git a/drivers/iio/accel/cros_ec_accel_legacy.c b/drivers/iio/accel=
/cros_ec_accel_legacy.c
> index 65f85faf6f31..b9f651e4ce99 100644
> --- a/drivers/iio/accel/cros_ec_accel_legacy.c
> +++ b/drivers/iio/accel/cros_ec_accel_legacy.c
> @@ -171,7 +171,8 @@ static int cros_ec_accel_legacy_probe(struct platform=
_device *pdev)
>  	if (!indio_dev)
>  		return -ENOMEM;
> =20
> -	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, true);
> +	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, true,
> +					cros_ec_sensors_capture, NULL);
>  	if (ret)
>  		return ret;
> =20
> @@ -191,11 +192,6 @@ static int cros_ec_accel_legacy_probe(struct platfor=
m_device *pdev)
>  		state->sign[CROS_EC_SENSOR_Z] =3D -1;
>  	}
> =20
> -	ret =3D devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
> -			cros_ec_sensors_capture, NULL);
> -	if (ret)
> -		return ret;
> -
>  	return devm_iio_device_register(dev, indio_dev);
>  }
> =20
> diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_lid_angle.c b/dri=
vers/iio/common/cros_ec_sensors/cros_ec_lid_angle.c
> index 1dcc2a16ab2d..e30a59fcf0f9 100644
> --- a/drivers/iio/common/cros_ec_sensors/cros_ec_lid_angle.c
> +++ b/drivers/iio/common/cros_ec_sensors/cros_ec_lid_angle.c
> @@ -97,7 +97,7 @@ static int cros_ec_lid_angle_probe(struct platform_devi=
ce *pdev)
>  	if (!indio_dev)
>  		return -ENOMEM;
> =20
> -	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, false);
> +	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, false, NULL, NULL);
>  	if (ret)
>  		return ret;
> =20
> diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drive=
rs/iio/common/cros_ec_sensors/cros_ec_sensors.c
> index 7dce04473467..62a0dd970988 100644
> --- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
> +++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
> @@ -231,7 +231,9 @@ static int cros_ec_sensors_probe(struct platform_devi=
ce *pdev)
>  	if (!indio_dev)
>  		return -ENOMEM;
> =20
> -	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, true);
> +	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, true,
> +					cros_ec_sensors_capture,
> +					cros_ec_sensors_push_data);
>  	if (ret)
>  		return ret;
> =20
> @@ -293,11 +295,6 @@ static int cros_ec_sensors_probe(struct platform_dev=
ice *pdev)
>  	else
>  		state->core.read_ec_sensors_data =3D cros_ec_sensors_read_cmd;
> =20
> -	ret =3D devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
> -			cros_ec_sensors_capture, NULL);
> -	if (ret)
> -		return ret;
> -
>  	return devm_iio_device_register(dev, indio_dev);
>  }
> =20
> diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors_core.c b/=
drivers/iio/common/cros_ec_sensors/cros_ec_sensors_core.c
> index b47da497a3c3..904cd26dd31f 100644
> --- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors_core.c
> +++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors_core.c
> @@ -12,6 +12,7 @@
>  #include <linux/iio/iio.h>
>  #include <linux/iio/kfifo_buf.h>
>  #include <linux/iio/trigger_consumer.h>
> +#include <linux/iio/triggered_buffer.h>
>  #include <linux/kernel.h>
>  #include <linux/mfd/cros_ec.h>
>  #include <linux/module.h>
> @@ -83,17 +84,78 @@ static void get_default_min_max_freq(enum motionsenso=
r_type type,
>  	}
>  }
> =20
> +int cros_ec_sensors_push_data(struct iio_dev *indio_dev,
> +			      s16 *data,
> +			      s64 timestamp)
> +{
> +	struct cros_ec_sensors_core_state *st =3D iio_priv(indio_dev);
> +	s16 *out;
> +	s64 delta;
> +	unsigned int i;
> +
> +	/*
> +	 * It can happen if we get a samples before the iio device is fully
> +	 * registered.

I'd really like to stop that happening as it seems like a nasty racey corne=
r case.
I'm not convinced there aren't 'half registered' cases we can still hit even
with this protection.  Hardware should be in a clean state before any
interrupts etc are registered.

However if you are sure this protection is enough that can be a job for ano=
ther day.

I suspect you get away with it because of the next check always failing in
those racey conditions as can't enable the buffer until we have a fully
set up device.

> +	 */
> +	if (!st)
> +		return 0;
> +
> +	/*
> +	 * Ignore samples if the buffer is not set: it is needed if the ODR is
> +	 * set but the buffer is not enabled yet.
> +	 */
> +	if (!iio_buffer_enabled(indio_dev))
> +		return 0;
> +
> +	out =3D (s16 *)st->samples;
> +	for_each_set_bit(i,
> +			 indio_dev->active_scan_mask,
> +			 indio_dev->masklength) {
> +		*out =3D data[i];
> +		out++;
> +	}
> +
> +	if (iio_device_get_clock(indio_dev) !=3D CLOCK_BOOTTIME)
> +		delta =3D iio_get_time_ns(indio_dev) - cros_ec_get_time_ns();
> +	else
> +		delta =3D 0;
> +
> +	iio_push_to_buffers_with_timestamp(indio_dev, st->samples,
> +					   timestamp + delta);
> +
> +	return 0;
> +}
> +EXPORT_SYMBOL_GPL(cros_ec_sensors_push_data);
> +
> +static void cros_ec_sensors_core_clean(void *arg)
> +{
> +	struct platform_device *pdev =3D (struct platform_device *)arg;
> +	struct cros_ec_sensorhub *sensor_hub =3D
> +		dev_get_drvdata(pdev->dev.parent);
> +	struct iio_dev *indio_dev =3D platform_get_drvdata(pdev);
> +	struct cros_ec_sensors_core_state *st =3D iio_priv(indio_dev);
> +	u8 sensor_num =3D st->param.info.sensor_num;
> +
> +	cros_ec_sensorhub_unregister_push_data(sensor_hub, sensor_num);
> +}
> +
>  /**
>   * cros_ec_sensors_core_init() - basic initialization of the core struct=
ure
>   * @pdev:		platform device created for the sensors
>   * @indio_dev:		iio device structure of the device
>   * @physical_device:	true if the device refers to a physical device
> + * @trigger_capture:    function pointer to call buffer is triggered,
> + *    for backward compatibility.
> + * @push_data:          function to call when cros_ec_sensorhub receives
> + *    a sample for that sensor.
>   *
>   * Return: 0 on success, -errno on failure.
>   */
>  int cros_ec_sensors_core_init(struct platform_device *pdev,
>  			      struct iio_dev *indio_dev,
> -			      bool physical_device)
> +			      bool physical_device,
> +			      cros_ec_sensors_capture_t trigger_capture,
> +			      cros_ec_sensorhub_push_data_cb_t push_data)
>  {
>  	struct device *dev =3D &pdev->dev;
>  	struct cros_ec_sensors_core_state *state =3D iio_priv(indio_dev);
> @@ -132,8 +194,6 @@ int cros_ec_sensors_core_init(struct platform_device =
*pdev,
>  	indio_dev->name =3D pdev->name;
> =20
>  	if (physical_device) {
> -		indio_dev->modes =3D INDIO_DIRECT_MODE;
> -

This particular changes seems odd. Are we dropping access via sysfs?
=46rom what I recall we don't actually do much with this currently in the
IIO core, but we 'might' in future ;)

>  		state->param.cmd =3D MOTIONSENSE_CMD_INFO;
>  		state->param.info.sensor_num =3D sensor_platform->sensor_num;
>  		ret =3D cros_ec_motion_send_host_cmd(state, 0);
> @@ -162,6 +222,25 @@ int cros_ec_sensors_core_init(struct platform_device=
 *pdev,
>  			state->frequencies[2] =3D
>  			    state->resp->info_3.max_frequency;
>  		}
> +
> +		ret =3D devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
> +						      trigger_capture, NULL);
> +		if (ret)
> +			return ret;
> +
> +		if (cros_ec_check_features(ec, EC_FEATURE_MOTION_SENSE_FIFO)) {
> +			ret =3D cros_ec_sensorhub_register_push_data(sensor_hub,
> +						sensor_platform->sensor_num,
> +						indio_dev, push_data);
> +			if (ret)
> +				return ret;
> +
> +			ret =3D devm_add_action_or_reset(dev,
> +						cros_ec_sensors_core_clean,
> +						pdev);
> +			if (ret)
> +				return ret;
> +		}
>  	}
> =20
>  	return 0;
> diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/c=
ros_ec_light_prox.c
> index d85a391e50c5..698b2ee81ebf 100644
> --- a/drivers/iio/light/cros_ec_light_prox.c
> +++ b/drivers/iio/light/cros_ec_light_prox.c
> @@ -178,7 +178,9 @@ static int cros_ec_light_prox_probe(struct platform_d=
evice *pdev)
>  	if (!indio_dev)
>  		return -ENOMEM;
> =20
> -	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, true);
> +	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, true,
> +					cros_ec_sensors_capture,
> +					cros_ec_sensors_push_data);
>  	if (ret)
>  		return ret;
> =20
> @@ -237,11 +239,6 @@ static int cros_ec_light_prox_probe(struct platform_=
device *pdev)
> =20
>  	state->core.read_ec_sensors_data =3D cros_ec_sensors_read_cmd;
> =20
> -	ret =3D devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
> -					      cros_ec_sensors_capture, NULL);
> -	if (ret)
> -		return ret;
> -
>  	return devm_iio_device_register(dev, indio_dev);
>  }
> =20
> diff --git a/drivers/iio/pressure/cros_ec_baro.c b/drivers/iio/pressure/c=
ros_ec_baro.c
> index 2354302375de..e1c86b22676c 100644
> --- a/drivers/iio/pressure/cros_ec_baro.c
> +++ b/drivers/iio/pressure/cros_ec_baro.c
> @@ -134,7 +134,9 @@ static int cros_ec_baro_probe(struct platform_device =
*pdev)
>  	if (!indio_dev)
>  		return -ENOMEM;
> =20
> -	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, true);
> +	ret =3D cros_ec_sensors_core_init(pdev, indio_dev, true,
> +					cros_ec_sensors_capture,
> +					cros_ec_sensors_push_data);
>  	if (ret)
>  		return ret;
> =20
> @@ -180,11 +182,6 @@ static int cros_ec_baro_probe(struct platform_device=
 *pdev)
> =20
>  	state->core.read_ec_sensors_data =3D cros_ec_sensors_read_cmd;
> =20
> -	ret =3D devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
> -					      cros_ec_sensors_capture, NULL);
> -	if (ret)
> -		return ret;
> -
>  	return devm_iio_device_register(dev, indio_dev);
>  }
> =20
> diff --git a/include/linux/iio/common/cros_ec_sensors_core.h b/include/li=
nux/iio/common/cros_ec_sensors_core.h
> index 0af918978f97..b8f573ca9dcc 100644
> --- a/include/linux/iio/common/cros_ec_sensors_core.h
> +++ b/include/linux/iio/common/cros_ec_sensors_core.h
> @@ -12,6 +12,7 @@
>  #include <linux/irqreturn.h>
>  #include <linux/platform_data/cros_ec_commands.h>
>  #include <linux/platform_data/cros_ec_proto.h>
> +#include <linux/platform_data/cros_ec_sensorhub.h>
> =20
>  enum {
>  	CROS_EC_SENSOR_X,
> @@ -32,6 +33,8 @@ enum {
>  /* Minimum sampling period to use when device is suspending */
>  #define CROS_EC_MIN_SUSPEND_SAMPLING_FREQUENCY 1000  /* 1 second */
> =20
> +typedef irqreturn_t (*cros_ec_sensors_capture_t)(int irq, void *p);
> +
>  /**
>   * struct cros_ec_sensors_core_state - state data for EC sensors IIO dri=
ver
>   * @ec:				cros EC device structure
> @@ -87,9 +90,14 @@ int cros_ec_sensors_read_cmd(struct iio_dev *indio_dev=
, unsigned long scan_mask,
> =20
>  struct platform_device;
>  int cros_ec_sensors_core_init(struct platform_device *pdev,
> -			      struct iio_dev *indio_dev, bool physical_device);
> +			      struct iio_dev *indio_dev, bool physical_device,
> +			      cros_ec_sensors_capture_t trigger_capture,
> +			      cros_ec_sensorhub_push_data_cb_t push_data);
> =20
>  irqreturn_t cros_ec_sensors_capture(int irq, void *p);
> +int cros_ec_sensors_push_data(struct iio_dev *indio_dev,
> +			      s16 *data,
> +			      s64 timestamp);
> =20
>  int cros_ec_motion_send_host_cmd(struct cros_ec_sensors_core_state *st,
>  				 u16 opt_length);

